{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SmallRye Stork 1.0.0.Beta1 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment The problem In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end. The solution Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies. What if the infrastructure provides such a feature? Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"Overview"},{"location":"#overview","text":"SmallRye Stork 1.0.0.Beta1 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment","title":"Overview"},{"location":"#the-problem","text":"In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end.","title":"The problem"},{"location":"#the-solution","text":"Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies.","title":"The solution"},{"location":"#what-if-the-infrastructure-provides-such-a-feature","text":"Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"What if the infrastructure provides such a feature?"},{"location":"concepts/","text":"Concepts This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly. Process overview When using the programmatic API of Stork, you: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni . Stork io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance. Service A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured. Service Instance The io.smallrye.stork.api.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import java.time.Duration ; import java.util.List ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import java.time.Duration ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } } Service Discovery The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking. Load Balancer The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Concepts"},{"location":"concepts/#concepts","text":"This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly.","title":"Concepts"},{"location":"concepts/#process-overview","text":"When using the programmatic API of Stork, you: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni .","title":"Process overview"},{"location":"concepts/#stork","text":"io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance.","title":"Stork"},{"location":"concepts/#service","text":"A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured.","title":"Service"},{"location":"concepts/#service-instance","text":"The io.smallrye.stork.api.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import java.time.Duration ; import java.util.List ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import java.time.Duration ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } }","title":"Service Instance"},{"location":"concepts/#service-discovery","text":"The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking.","title":"Service Discovery"},{"location":"concepts/#load-balancer","text":"The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Load Balancer"},{"location":"consul/","text":"Consul Service Discovery Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery. Dependency First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.0.0.Beta1 </version> </dependency> Configuration For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host. consul-port No 8500 The Consul port. use-health-checks No true Whether to use health check. application No The application name; if not defined Stork service name will be used. refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS)","title":"Consul"},{"location":"consul/#consul-service-discovery","text":"Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery.","title":"Consul Service Discovery"},{"location":"consul/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.0.0.Beta1 </version> </dependency>","title":"Dependency"},{"location":"consul/#configuration","text":"For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host. consul-port No 8500 The Consul port. use-health-checks No true Whether to use health check. application No The application name; if not defined Stork service name will be used. refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS)","title":"Configuration"},{"location":"custom-load-balancer/","text":"Implement your own load balancer mechanism Stork is extensible, and you can implement your service selection (load-balancer) mechanism. Dependencies To implement your Load Balancer Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom load balancer, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> stork-core </artifactId> <version> 1.0.0.Beta1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.0.0.Beta1 </version> </dependency> Implementing a load balancer provider Load balancer implementation consists of three elements: LoadBalancer which is responsible for selecting service instances for a single Stork service LoadBalancerProvider which creates instances of LoadBalancer for a given load balancer type LoadBalancerProviderConfiguration which is a configuration for the load balancer A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.load-balancer = acme A LoadBalancerProvider implementation needs to be annotated with @LoadBalancerType that defines the type . Any configuration properties that the provider expects should be defined with @LoadBalancerAttribute annotations placed on the provider. A load balancer provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.LoadBalancerAttribute ; import io.smallrye.stork.api.config.LoadBalancerType ; import io.smallrye.stork.spi.LoadBalancerProvider ; @LoadBalancerType ( \"acme\" ) @LoadBalancerAttribute ( name = \"my-attribute\" , description = \"Attribute that alters the behavior of the LoadBalancer\" ) public class AcmeLoadBalancerProvider implements LoadBalancerProvider < AcmeLoadBalancerProviderConfiguration > { @Override public LoadBalancer createLoadBalancer ( AcmeLoadBalancerProviderConfiguration config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } Note, that the LoadBalancerProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the name of the provider class. The next step is to implement the LoadBalancer interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package examples ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.NoServiceInstanceFoundException ; import io.smallrye.stork.api.ServiceInstance ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( AcmeLoadBalancerProviderConfiguration config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { if ( serviceInstances . isEmpty ()) { throw new NoServiceInstanceFoundException ( \"No services found.\" ); } int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } } This implementation is simplistic and just picks a random instance from the received list. Using your load balancer In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = ... stork.my-service.load-balancer = acme Then, Stork will use your implementation to select the my-service service instance.","title":"Custom"},{"location":"custom-load-balancer/#implement-your-own-load-balancer-mechanism","text":"Stork is extensible, and you can implement your service selection (load-balancer) mechanism.","title":"Implement your own load balancer mechanism"},{"location":"custom-load-balancer/#dependencies","text":"To implement your Load Balancer Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom load balancer, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> stork-core </artifactId> <version> 1.0.0.Beta1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.0.0.Beta1 </version> </dependency>","title":"Dependencies"},{"location":"custom-load-balancer/#implementing-a-load-balancer-provider","text":"Load balancer implementation consists of three elements: LoadBalancer which is responsible for selecting service instances for a single Stork service LoadBalancerProvider which creates instances of LoadBalancer for a given load balancer type LoadBalancerProviderConfiguration which is a configuration for the load balancer A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.load-balancer = acme A LoadBalancerProvider implementation needs to be annotated with @LoadBalancerType that defines the type . Any configuration properties that the provider expects should be defined with @LoadBalancerAttribute annotations placed on the provider. A load balancer provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.LoadBalancerAttribute ; import io.smallrye.stork.api.config.LoadBalancerType ; import io.smallrye.stork.spi.LoadBalancerProvider ; @LoadBalancerType ( \"acme\" ) @LoadBalancerAttribute ( name = \"my-attribute\" , description = \"Attribute that alters the behavior of the LoadBalancer\" ) public class AcmeLoadBalancerProvider implements LoadBalancerProvider < AcmeLoadBalancerProviderConfiguration > { @Override public LoadBalancer createLoadBalancer ( AcmeLoadBalancerProviderConfiguration config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } Note, that the LoadBalancerProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the name of the provider class. The next step is to implement the LoadBalancer interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package examples ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.NoServiceInstanceFoundException ; import io.smallrye.stork.api.ServiceInstance ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( AcmeLoadBalancerProviderConfiguration config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { if ( serviceInstances . isEmpty ()) { throw new NoServiceInstanceFoundException ( \"No services found.\" ); } int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } } This implementation is simplistic and just picks a random instance from the received list.","title":"Implementing a load balancer provider"},{"location":"custom-load-balancer/#using-your-load-balancer","text":"In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = ... stork.my-service.load-balancer = acme Then, Stork will use your implementation to select the my-service service instance.","title":"Using your load balancer"},{"location":"custom-service-discovery/","text":"Implement your own service discovery mechanism Stork is extensible, and you can implement your own service discovery mechanism. Dependencies To implement your Service Discovery Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom discovery, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> stork-core </artifactId> <version> 1.0.0.Beta1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.0.0.Beta1 </version> </dependency> Implementing a service discovery provider Service discovery implementation consists of three elements: ServiceDiscovery which is responsible for locating service instances for a single Stork service ServiceDiscoveryProvider which creates instances of ServiceDiscovery for a given service discovery type . ServiceDiscoveryProviderConfiguration which is a configuration for the discovery A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.service-discovery = acme A ServiceDiscoveryProvider implementation needs to be annotated with @ServiceDiscoveryType that defines the type . Any configuration properties that the provider expects should be defined with @ServiceDiscoveryAttribute annotations placed on the provider. A service discovery provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.spi.StorkInfrastructure ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; @ServiceDiscoveryType ( \"acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < AcmeServiceDiscoveryProviderConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( AcmeServiceDiscoveryProviderConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new AcmeServiceDiscovery ( config ); } } Note, that the ServiceDiscoveryProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the name of the provider class. The next step is to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.Collections ; import java.util.List ; import java.util.Map ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.spi.ServiceInstanceIds ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( AcmeServiceDiscoveryProviderConfiguration configuration ) { this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port // The last parameter specifies whether the communication with the instance should happen over a secure connection DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That's why the method returns a Uni . Most of the time, the lookup is a remote operation. Using your service discovery In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service.","title":"Custom"},{"location":"custom-service-discovery/#implement-your-own-service-discovery-mechanism","text":"Stork is extensible, and you can implement your own service discovery mechanism.","title":"Implement your own service discovery mechanism"},{"location":"custom-service-discovery/#dependencies","text":"To implement your Service Discovery Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom discovery, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> stork-core </artifactId> <version> 1.0.0.Beta1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.0.0.Beta1 </version> </dependency>","title":"Dependencies"},{"location":"custom-service-discovery/#implementing-a-service-discovery-provider","text":"Service discovery implementation consists of three elements: ServiceDiscovery which is responsible for locating service instances for a single Stork service ServiceDiscoveryProvider which creates instances of ServiceDiscovery for a given service discovery type . ServiceDiscoveryProviderConfiguration which is a configuration for the discovery A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.service-discovery = acme A ServiceDiscoveryProvider implementation needs to be annotated with @ServiceDiscoveryType that defines the type . Any configuration properties that the provider expects should be defined with @ServiceDiscoveryAttribute annotations placed on the provider. A service discovery provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.spi.StorkInfrastructure ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; @ServiceDiscoveryType ( \"acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < AcmeServiceDiscoveryProviderConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( AcmeServiceDiscoveryProviderConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new AcmeServiceDiscovery ( config ); } } Note, that the ServiceDiscoveryProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the name of the provider class. The next step is to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.Collections ; import java.util.List ; import java.util.Map ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.spi.ServiceInstanceIds ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( AcmeServiceDiscoveryProviderConfiguration configuration ) { this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port // The last parameter specifies whether the communication with the instance should happen over a secure connection DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That's why the method returns a Uni . Most of the time, the lookup is a remote operation.","title":"Implementing a service discovery provider"},{"location":"custom-service-discovery/#using-your-service-discovery","text":"In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service.","title":"Using your service discovery"},{"location":"eureka/","text":"Eureka Service Discovery Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery. Dependency First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-eureka </artifactId> <version> 1.0.0.Beta1 </version> </dependency> ````` ## Configuration For each application instance expected to be registered in Eureka, configure the lookup: ```properties stork.my-service.service-discovery=eureka stork.my-service.service-discovery.eureka-host=localhost stork.my-service.service-discovery.eureka-port=8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description eureka-host Yes The Eureka server host. eureka-port No 8761 The Eureka server port. eureka-context-path No / The Eureka server root context path. application No The Eureka application Id; if not defined Stork service name will be used eureka-trust-all No false Enable/Disable the TLS certificate verification eureka-tls No false Use TLS to connect to the Eureka server instance No The Eureka application instance Id refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS) The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances.","title":"Eureka"},{"location":"eureka/#eureka-service-discovery","text":"Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery.","title":"Eureka Service Discovery"},{"location":"eureka/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-eureka </artifactId> <version> 1.0.0.Beta1 </version> </dependency> ````` ## Configuration For each application instance expected to be registered in Eureka, configure the lookup: ```properties stork.my-service.service-discovery=eureka stork.my-service.service-discovery.eureka-host=localhost stork.my-service.service-discovery.eureka-port=8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description eureka-host Yes The Eureka server host. eureka-port No 8761 The Eureka server port. eureka-context-path No / The Eureka server root context path. application No The Eureka application Id; if not defined Stork service name will be used eureka-trust-all No false Enable/Disable the TLS certificate verification eureka-tls No false Use TLS to connect to the Eureka server instance No The Eureka application instance Id refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS) The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances.","title":"Dependency"},{"location":"kubernetes/","text":"Kubernetes Service Discovery Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery. Dependency First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-kubernetes </artifactId> <version> 1.0.0.Beta1 </version> </dependency> A few words about server authentication. Stork uses Fabric8 Kubernetes Client to access the Kubernetes resources, concretely the DefaultKubernetesClient implementation. It will try to read the ~/.kube/config file in your home directory and load information required for authenticating with the Kubernetes API server. If you are using DefaultKubernetesClient from inside a Pod, it will load ~/.kube/config from the ServiceAccount volume mounted inside the Pod. You can override this configuration if you want a more complex configuration. Configuration For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No The Kubernetes API host. k8s-namespace No The namespace of the service. Use all to discover all namespaces. application No The Eureka application Id; if not defined Stork service name will be used. refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS)","title":"Kubernetes"},{"location":"kubernetes/#kubernetes-service-discovery","text":"Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery.","title":"Kubernetes Service Discovery"},{"location":"kubernetes/#dependency","text":"First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-kubernetes </artifactId> <version> 1.0.0.Beta1 </version> </dependency>","title":"Dependency"},{"location":"kubernetes/#a-few-words-about-server-authentication","text":"Stork uses Fabric8 Kubernetes Client to access the Kubernetes resources, concretely the DefaultKubernetesClient implementation. It will try to read the ~/.kube/config file in your home directory and load information required for authenticating with the Kubernetes API server. If you are using DefaultKubernetesClient from inside a Pod, it will load ~/.kube/config from the ServiceAccount volume mounted inside the Pod. You can override this configuration if you want a more complex configuration.","title":"A few words about server authentication."},{"location":"kubernetes/#configuration","text":"For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No The Kubernetes API host. k8s-namespace No The namespace of the service. Use all to discover all namespaces. application No The Eureka application Id; if not defined Stork service name will be used. refresh-period No 5M Service discovery cache refresh period. secure No false Whether the communication should use a secure connection (e.g. HTTPS)","title":"Configuration"},{"location":"quarkus/","text":"Using Stork with Quarkus Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples. The project You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail. The client To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); } The service In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call. Dependencies To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.0.0.Beta1 </version> </dependency> Note No need to add a dependency for the round-robin load-balancer. This strategy is built-in. When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers. The config The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: stork.hello-service.service-discovery = consul stork.hello-service.service-discovery.consul-host = localhost stork.hello-service.service-discovery.consul-port = 8500 Note When no load-balancing is configured, Stork uses a round-robin.","title":"Using Stork with Quarkus"},{"location":"quarkus/#using-stork-with-quarkus","text":"Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples.","title":"Using Stork with Quarkus"},{"location":"quarkus/#the-project","text":"You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail.","title":"The project"},{"location":"quarkus/#the-client","text":"To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); }","title":"The client"},{"location":"quarkus/#the-service","text":"In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call.","title":"The service"},{"location":"quarkus/#dependencies","text":"To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.0.0.Beta1 </version> </dependency> Note No need to add a dependency for the round-robin load-balancer. This strategy is built-in. When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers.","title":"Dependencies"},{"location":"quarkus/#the-config","text":"The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: stork.hello-service.service-discovery = consul stork.hello-service.service-discovery.consul-host = localhost stork.hello-service.service-discovery.consul-port = 8500 Note When no load-balancing is configured, Stork uses a round-robin.","title":"The config"},{"location":"response-time/","text":"Least Response Time Load Balancing The least-response-time load balancing strategy monitors the operations and selects the fastest instance. This load balancer collects statistics and determines which instance will provide the shorter response time. Dependency First, you need to add the least-response-time load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-response-time </artifactId> <version> 1.0.0.Beta1 </version> </dependency> Configuration For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = least-response-time","title":"Response Time"},{"location":"response-time/#least-response-time-load-balancing","text":"The least-response-time load balancing strategy monitors the operations and selects the fastest instance. This load balancer collects statistics and determines which instance will provide the shorter response time.","title":"Least Response Time Load Balancing"},{"location":"response-time/#dependency","text":"First, you need to add the least-response-time load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-response-time </artifactId> <version> 1.0.0.Beta1 </version> </dependency>","title":"Dependency"},{"location":"response-time/#configuration","text":"For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = least-response-time","title":"Configuration"},{"location":"round-robin/","text":"Round-Robin Load Balancing The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases. The round-robin strategy is the default load-balancing strategy. It is provided by Stork itself, and so does not require an additional dependency. Configuration There is no need to configure the load-balancing strategy to be round-robin . Stork automatically uses this strategy when none are configured. However, you can also configure it explicitly as follows: stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = round-robin","title":"Round Robin"},{"location":"round-robin/#round-robin-load-balancing","text":"The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases. The round-robin strategy is the default load-balancing strategy. It is provided by Stork itself, and so does not require an additional dependency.","title":"Round-Robin Load Balancing"},{"location":"round-robin/#configuration","text":"There is no need to configure the load-balancing strategy to be round-robin . Stork automatically uses this strategy when none are configured. However, you can also configure it explicitly as follows: stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = round-robin","title":"Configuration"}]}